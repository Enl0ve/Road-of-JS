<h1>unary函数</h1>

#### 函数的原型方法中有一个map函数。map函数与之前定义的forEach方法非常相似，唯一的区别是map函数返回了回调函数的结果。

#### 假设我们需要将一个数组元素的值放大两倍，我们可以这么写

```js
    [1, 2, 3].map(el => {
        return el*2;
    })
```
#### map函数用3个参数调用了函数，分别是element、index和arr。假设我们要把字符串数组解析为整数数组 。我们有一个内置的函数称为parseInt,它接受两个参数parse和radix，如果可能，该函数会把传入的parse转换为数字。如果把parseInt传给map函数，map会把index的值传给parseInt的radix参数，这将产生意想不到的行为 。

```js
    ['1', '2', '3'].map(parseInt);
    => [1, NaN, NaN]
```

#### 从上面给以看出，不是我们期望的结果。我们需要把parseInt函数转换为一个只接受一个参数的函数。下面介绍一下unary函数，它的任务是接受一个给定的多参数函数，并把它转换为一个只接受一个参数的函数。

```js
    const unary = (fn) => {
        fn.length === 1? fn: (arg) => fn(arg)
    }
```

#### 我们检查传入的fn是否有一个长度为1的参数列表（可以通过length属性查看）。如果有，什么也不做，如果没有，就返回一个新函数，它只接受一个参数arg，并用该参数调用fn。

```js
    ['1', '2', '3'].map(unary(parseInt));
    => [1, 2, 3]
```

#### unary函数返回了一个新函数(parseInt函数的克隆体)，它只接受一个参数。如此，map函数传入的index和arr参数就不会对程序产生影响，我们就能得到期望的值 。
