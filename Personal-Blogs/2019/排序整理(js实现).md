> ### 术语说明：
1. #### 稳定：如果a原本在b之前，且a=b,排序之后a仍然在b之前。
2. #### 不稳定：如果a原本在b之前，且a=b,排序之后a可能在b之后
3. #### 内排序：所有排序操作都在内存中完成
4. #### 外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行
5. #### 时间复杂度：运行一个算法所需要消耗的时间
6. #### 空间复杂度：运行一个程序所需消耗的内存大小

> ### 多种排序算法总结
|排序算法|平均时间复杂度|最好情况|最坏情况|空间复杂度|排序方式|稳定性|
|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
|冒泡排序|$O(n^{2})$|$O(n)$|$O(n^{2})$|$O(1)$|内排|稳定|
|选择排序|$O(n^{2})$|$O(n^{2})$|$O(n^{2})$|$O(1)$|内排|不稳定|
|插入排序|$O(n^{2})$|$O(n)$|$O(n^{2})$|$O(1)$|内排|稳定|
|希尔排序|$O(n\log n)$|$O(n\log^2n)$|$O(n\log^2n)$|$O(1)$|内排|不稳定|
|归并排序|$O(n\log n)$|$O(n\log n)$|$O(n\log n)$|$O(n)$|外排|稳定|
|快速排序|$O(n\log n)$|$O(n\log n)$|$O(n^{2})$|$O(\log n)$|内排|不稳定|
|堆排序|$O(n\log n)$|$O(n\log n)$|$O(n\log n)$|$O(1)$|内排|不稳定|
|计数排序|$O(n+k)$|$O(n+k)$|$O(n+k)$|$O(k)$|外排|稳定|
|桶排序|$O(n+k)$|$O(n+k)$|$O(n^{2})$|$O(n+k)$|外排|稳定|
|基数排序|$O(n\times{k})$|$O(n\times{k})$|$O(n\times{k})$|$O(n+k)$|外排|稳定|
> ### <b style="color:yellow">Note:</b>
> 1. n指的是数据规模
> 2. k指的是桶的个数
> 3. In-place:占用常数内存，不占用额外内存
> 4. Out-place: 占用额外内存

> ### 算法分类

>比较和非排序的区别

#### 常见的快排、归并排序、堆排序、冒泡排序等属于比较排序，在最终的比较结果里，元素之间的次序依赖于他们之间的比较，每个数都必须和其他数进行比较，才能确定自己的位置。
#### 在冒泡排序之类的排序中，问题规模是n,需要比较n次，所以时间平均复杂度是$O(n^2)$。在归并排序、快速排序中，问题规模通过分治法消减为$\log n$次，所以时间平均复杂度是$O(n\log n)$。
#### 比较排序的优势是，适用于各种规模的数据，也不在乎数据的分布，都能进行排序。可以说，比较排序适用于一切需要排序的情况。
#### 计数排序、基数排序、桶排序则属于非比较排序。非比较排序是通过确定每个元素之前，应该有多少个元素来排序。针对数组arr，计算arr之前有多少个元素，则唯一确定了arr在排序后数组中的位置。
#### 非比较排序只要确定每个元素之前的已有的元素个数即可，所有一次遍历即可解决。算法时间复杂度O(n)。非比较排序时间复杂度底，但由于非比较排序需要占用空间来确定唯一位置。所以对数据规模和数据分布有一定的要求。

> ### 排序算法实现

## 冒泡排序(bubble sort)
<h3> <b>算法描述</b> </h3>
##### 比较相邻的元素，如果第一个比第二个大，就交换他们两个；对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；针对所有的元素重复以上的步骤，除了最后一个；重复步骤1~3，直到排序完成。

### 代码实现
```js
function swap(a, b) {
    a = a ^ b;
    b = a ^ b;
    a = a ^ b;
    return [a, b];
}

function bubbleSort(nums) {
    var h = nums.length - 1;
    for (var i = h; h > 0; h--) {
        for (var j = 0; j <= i; j++) {
            if (nums[j] > nums[j + 1])
                [nums[j], nums[j + 1]] = swap(nums[j], nums[j + 1])
        }
    }
    return nums;
}
```

## 选择排序(selection sort)
### 算法描述
从数组中选择最小元素，将它与数组的第一个元素交换位置。再从数组剩下的元素中选择出最小的元素，将它与数组的第二个元素交换位置。不断进行这样的操作，直到将整个数组排序。

选择排序需要 \~N<sup>2</sup>/2 次比较和 \~N 次交换，它的运行时间与输入无关，这个特点使得它对一个已经排序的数组也需要这么多的比较和交换操作。

### 代码实现
```js
/**
 * 选择排序
 */

function selectonSort(nums) {
    for (var i = 1; i < nums.length; i++) {
        for (var j = i + 1, min = nums[i]; j < nums.length; j++) {
            if (min > nums[j]) {
                [min, nums[j]] = swap(min, nums[j]);
            }
        }
        nums[i] = min;
    }
    return nums;
}
```
## 插入排序(insertion sort)
### 算法描述
每次都将当前元素插入到左侧已经排序的数组中，使得插入之后左侧数组依然有序。

对于数组 {3, 5, 2, 4, 1}，它具有以下逆序：(3, 2), (3, 1), (5, 2), (5, 4), (5, 1), (2, 1), (4, 1)，插入排序每次只能交换相邻元素，令逆序数量减少 1，因此插入排序需要交换的次数为逆序数量。

插入排序的时间复杂度取决于数组的初始顺序，如果数组已经部分有序了，那么逆序较少，需要的交换次数也就较少，时间复杂度较低。

- 平均情况下插入排序需要 \~N<sup>2</sup>/4 比较以及 \~N<sup>2</sup>/4 次交换；
- 最坏的情况下需要 \~N<sup>2</sup>/2 比较以及 \~N<sup>2</sup>/2 次交换，最坏的情况是数组是倒序的；
- 最好的情况下需要 N-1 次比较和 0 次交换，最好的情况就是数组已经有序了。

```js
/**
 * 插入排序
 */
function insertionSort(nums) {
    var N = nums.length;
    for (var i = 1; i < N; i++) {
        for (var j = i; j < N && nums[j] < nums[j - 1]; j--) {
            [nums[j - 1], nums[j]] = swap(nums[j - 1], nums[j]);
        }
    }
    return nums;
}
```

## 希尔排序
### 算法描述
对于大规模的数组，插入排序很慢，因为它只能交换相邻的元素，每次只能将逆序数量减少 1。希尔排序的出现就是为了解决插入排序的这种局限性，它通过交换不相邻的元素，每次可以将逆序数量减少大于 1。

希尔排序使用插入排序对间隔 h 的序列进行排序。通过不断减小 h，最后令 h=1，就可以使得整个数组是有序的。

```js
/**
 * 希尔排序
 */
function Shell(nums) {
    var N = nums.length,
        h = 1;
    while (h < Math.floor(N / 3)) {
        h = h * 3 + 1;
    }

    while (h >= 1) {
        for (var i = h; i < N; i++) {
            for (var j = i; j < N && nums[j] < nums[j - h]; j -= h) {
                [nums[j - h], nums[j]] = swap(nums[j - h], nums[j]);
            }
        }
        h = Math.floor(h / 3);
    }
    return nums;
}
```
希尔排序的运行时间达不到平方级别，使用递增序列 1, 4, 13, 40, ...  的希尔排序所需要的比较次数不会超过 N 的若干倍乘于递增序列的长度。后面介绍的高级排序算法只会比希尔排序快两倍左右。

## 归并排序
### 算法描述
归并排序的思想是将数组分成两部分，分别进行排序，然后归并起来。

### 1. 归并方法
归并方法将数组中两个已经排序的部分归并成一个。
```js

```

## 快速排序
### 算法描述
设要排序的数组是A[0]……A[N-1]，首先任意选取一个数据（通常选用数组的第一个数）作为关键数据，然后将所有比它小的数都放到它左边，所有比它大的数都放到它右边，这个过程称为一趟快速排序。值得注意的是，快速排序不是一种稳定的排序算法，也就是说，多个相同的值的相对位置也许会在算法结束时产生变动。
一趟快速排序的算法是：
1）设置两个变量i、j，排序开始的时候：i=0，j=N-1；
2）以第一个数组元素作为关键数据，赋值给key，即key=A[0]；
3）从j开始向前搜索，即由后开始向前搜索(j--)，找到第一个小于key的值A[j]，将A[j]和A[i]的值交换；
4）从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]的值交换；
5）重复第3、4步，直到i=j； (3,4步中，没找到符合条件的值，即3中A[j]不小于key,4中A[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。

```js
/**
 * @description 切分
 * @param {*} nums 
 * @param {*} left 
 * @param {*} right 
 */
function partion(nums, left = 0, right = nums.length - 1) {
    if (left >= right) {
        return;
    }
    var i = left,
        j = right,
        key = nums[i];
    while (i < j) {
        while (nums[j] >= key && i != j) j--;
        if (i < j) {
            [nums[i], nums[j]] = swap(nums[i], nums[j]);
        }
        while (nums[i] <= key && i != j) i++;
        if (i < j) {
            [nums[i], nums[j]] = swap(nums[i], nums[j]);
        }
    }
    partion(nums, left, j - 1);
    partion(nums, j + 1, right);

    return nums;
}

function QuickSort(nums) {
    var newArr = nums.concat();
    newArr = partion(nums);
    return newArr;
}
```


## 堆排序
### 1.堆
堆中某个节点的值总是大于等于其子节点的值，并且堆是一颗完全二叉树。

堆可以用数组来表示，这是因为堆是完全二叉树，而完全二叉树很容易就存储在数组中。位置 k 的节点的父节点位置为 k/2，而它的两个子节点的位置分别为 2k 和 2k+1。这里不使用数组索引为 0 的位置，是为了更清晰地描述节点的位置关系。



## 计数排序
计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。
计数排序(Counting sort)是一种稳定的排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。它只能对整数进行排序。

### 算法描述
找出待排序的数组中最大和最小的元素；
统计数组中每个值为i的元素出现的次数，存入数组C的第i项；
对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；
反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。

```js
/**
 * 计数排序 
 */
function CountingSort(nums) {
    var aux = [],
        result = [],
        min = nums[0],
        max = nums[0],
        count = 0;
    for (var el of nums) {
        if (min > el) {
            [min, el] = swap(min, el);
        }
        if (max < el) {
            [max, el] = swap(max, el);
        }
    }

    for (var i = min; i <= max; i++) {
        aux[i] = 0;
    }

    for (var el of nums) {
        aux[el]++;
        count++;
    }

    for (var i = min; i < nums.length && count > 0; i++) {
        while (aux[i] > 0) {
            result.push(i);
            aux[i]--;
            count--;
        }
    }
    return result;
}
```
### 算法分析
当输入的元素是n 个0到k之间的整数时，它的运行时间是 O(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。
最佳情况：T(n) = O(n+k)  最差情况：T(n) = O(n+k)  平均情况：T(n) = O(n+k)

## 桶排序(bucket sort)
桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。
桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排
### 算法描述
人为设置一个BucketSize，作为每个桶所能放置多少个不同数值（例如当BucketSize==5时，该桶可以存放｛1,2,3,4,5｝这几种数字，但是容量不限，即可以存放100个3）；
遍历输入数据，并且把数据一个一个放到对应的桶里去；
对每个不是空的桶进行排序，可以使用其它排序方法，也可以递归使用桶排序；
从不是空的桶里把排好序的数据拼接起来。
注意，如果递归使用桶排序为各个桶排序，则当桶数量为1时要手动减小BucketSize增加下一循环桶的数量，否则会陷入死循环，导致内存溢出。

### 代码实现
```js

```