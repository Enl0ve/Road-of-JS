<!-- GFM-TOC -->
* [有序数组的 Two Sum](#有序数组的-two-sum)
* [两数平方和](#两数平方和)
* [反转字符串中的元音字符](#反转字符串中的元音字符)
* [回文字符串](#回文字符串)
* [归并两个有序数组](#归并两个有序数组)
* [判断链表是否存在环](#判断链表是否存在环)
* [最长子序列](#最长子序列)
<!-- GFM-TOC -->


双指针主要用于遍历数组，两个指针指向不同的元素，从而协同完成任务。

# 有序数组的 Two Sum

[Leetcode ：167. Two Sum II - Input array is sorted (Easy)](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description/)

```html
Input: numbers={2, 7, 11, 15}, target=9
Output: index1=1, index2=2
```

题目描述：在有序数组中找出两个数，使它们的和为 target。

使用双指针，一个指针指向值较小的元素，一个指针指向值较大的元素。指向较小元素的指针从头向尾遍历，指向较大元素的指针从尾向头遍历。

- 如果两个指针指向元素的和 sum == target，那么得到要求的结果；
- 如果 sum > target，移动较大的元素，使 sum 变小一些；
- 如果 sum < target，移动较小的元素，使 sum 变大一些。

```java
public int[] twoSum(int[] numbers, int target) {
    int i = 0, j = numbers.length - 1;
    while (i < j) {
        int sum = numbers[i] + numbers[j];
        if (sum == target) {
            return new int[]{i + 1, j + 1};
        } else if (sum < target) {
            i++;
        } else {
            j--;
        }
    }
    return null;
}
```
```js
function twoSum(num, target) {
    var i = 0,
        j = num.length - 1,
        sum = 0;
    while (i < j) {
        sum = num[i] + num[j];

        if (sum == target) {
            return [num[i], num[j]];
        } else if (sum > target) {
            j--;
        } else {
            i++;
        }
    }
    return null;
}
```

# 两数平方和

[633. Sum of Square Numbers (Easy)](https://leetcode.com/problems/sum-of-square-numbers/description/)

```html
Input: 5
Output: True
Explanation: 1 * 1 + 2 * 2 = 5
```

题目描述：判断一个数是否为两个数的平方和。

```java
public boolean judgeSquareSum(int c) {
    int i = 0, j = (int) Math.sqrt(c);
    while (i <= j) {
        int powSum = i * i + j * j;
        if (powSum == c) {
            return true;
        } else if (powSum > c) {
            j--;
        } else {
            i++;
        }
    }
    return false;
}
```

```js
function judgeSquareSum(c) {
    var i = 0,
        j = Math.floor(Math.sqrt(c)),
        powerSum = 0;
    while (i < j) {
        powerSum = i * i + j * j;
        if (powerSum == c) {
            return true;
        } else if (powerSum > c) {
            j--;
        } else {
            i++;
        }
    }
    return false;
}
```

# 反转字符串中的元音字符

[345. Reverse Vowels of a String (Easy)](https://leetcode.com/problems/reverse-vowels-of-a-string/description/)

```html
Given s = "leetcode", return "leotcede".
```

使用双指针指向待反转的两个元音字符，一个指针从头向尾遍历，一个指针从尾到头遍历。

```java
private final static HashSet<Character> vowels = new HashSet<>(Arrays.asList('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'));

public String reverseVowels(String s) {
    int i = 0, j = s.length() - 1;
    char[] result = new char[s.length()];
    while (i <= j) {
        char ci = s.charAt(i);
        char cj = s.charAt(j);
        if (!vowels.contains(ci)) {
            result[i++] = ci;
        } else if (!vowels.contains(cj)) {
            result[j--] = cj;
        } else {
            result[i++] = cj;
            result[j--] = ci;
        }
    }
    return new String(result);
}
```

```js
//法一
function reverseVowels(str) {
    var vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'],
        i = 0,
        j = str.length - 1,
        num = str.split('');
    while (i <= j) {
        if (vowels.includes(str.charAt(i))) {
            if (vowels.includes(num[j])) {
                var temp = num[j];
                num[j] = num[i];
                num[i] = temp;
                i++;
                j--;
            } else {
                j--;
            }
        } else {
            i++;
        }
    }
    return num.join('');
}
//法二
function reverseVowels(str) {
    var vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'],
        nums = [],
        i = 0,
        j = str.length - 1;
    while (i <= j) {
        if (vowels.includes(str.charAt(i))) {
            if (vowels.includes(str.charAt(j))) {
                nums[i] = str.charAt(j);
                nums[j] = str.charAt(i);
                i++;
                j--
            } else {
                nums[j] = str.charAt(j);
                j--;
            }
        } else {
            nums[i] = str.charAt(i);
            i++;
        }
    }

    return nums.join('');
}
```

# 回文字符串

[680. Valid Palindrome II (Easy)](https://leetcode.com/problems/valid-palindrome-ii/description/)

```html
Input: "abca"
Output: True
Explanation: You could delete the character 'c'.
```

题目描述：可以删除一个字符，判断是否能构成回文字符串。

```java
public boolean validPalindrome(String s) {
    int i = -1, j = s.length();
    while (++i < --j) {
        if (s.charAt(i) != s.charAt(j)) {
            return isPalindrome(s, i, j - 1) || isPalindrome(s, i + 1, j);
        }
    }
    return true;
}

private boolean isPalindrome(String s, int i, int j) {
    while (i < j) {
        if (s.charAt(i++) != s.charAt(j--)) {
            return false;
        }
    }
    return true;
}
```

```js
function validPalindrome(str) {
    var i = -1,
        j = str.length;
    while (++i < --j) {
        if (str.charAt(i) != str.charAt(j)) {
            return isPalindrome(str, i, j - 1) || isPalindrome(str, i + 1, j);
        }
    }
    return true;
}

function isPalindrome(s, i, j) {
    while (i < j) {
        if (s.charAt(i++) != s.charAt(j--)) {
            return false;
        }
    }
    return true;
}
```

# 归并两个有序数组

[88. Merge Sorted Array (Easy)](https://leetcode.com/problems/merge-sorted-array/description/)

```html
Input:
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6],       n = 3

Output: [1,2,2,3,5,6]
```

题目描述：把归并结果存到第一个数组上。

需要从尾开始遍历，否则在 nums1 上归并得到的值会覆盖还未进行归并比较的值。

```java
public void merge(int[] nums1, int m, int[] nums2, int n) {
    int index1 = m - 1, index2 = n - 1;
    int indexMerge = m + n - 1;
    while (index1 >= 0 || index2 >= 0) {
        if (index1 < 0) {
            nums1[indexMerge--] = nums2[index2--];
        } else if (index2 < 0) {
            nums1[indexMerge--] = nums1[index1--];
        } else if (nums1[index1] > nums2[index2]) {
            nums1[indexMerge--] = nums1[index1--];
        } else {
            nums1[indexMerge--] = nums2[index2--];
        }
    }
}
```

```js
function merge(nums1, m, nums2, n) {
    var index1 = m - 1,
        index2 = n - 1,
        mergeIndex = m + n - 1;
    while (index1 >= 0 || index2 >= 0) {
        if (index1 < 0) {
            nums1[mergeIndex--] = nums2[index2--];
        } else if (index2 < 0) {
            nums1[mergeIndex--] = nums1[index1--];
        } else if (nums1[index1] < nums2[index2]) {
            nums1[mergeIndex--] = nums2[index2--];
        } else {
            nums1[mergeIndex--] = nums1[index1--];
        }
    }
    return nums1;
}
```

# 判断链表是否存在环

[141. Linked List Cycle (Easy)](https://leetcode.com/problems/linked-list-cycle/description/)

使用双指针，一个指针每次移动一个节点，一个指针每次移动两个节点，如果存在环，那么这两个指针一定会相遇。

```java
public boolean hasCycle(ListNode head) {
    if (head == null) {
        return false;
    }
    ListNode l1 = head, l2 = head.next;
    while (l1 != null && l2 != null && l2.next != null) {
        if (l1 == l2) {
            return true;
        }
        l1 = l1.next;
        l2 = l2.next.next;
    }
    return false;
}
```

```js
function hasCycle(head) {
    if(head == null) {
        return false;
    }

    l1 = head;
    l2 = head.next;
    while(l1 != null && l2 != null && l2.next!= null) {
        if(l1 == l2) {
            return true;
        }
        l1 = l1.next;
        l2 = l2.next.next;
    }
    return false;
}
```

# 最长子序列

[524. Longest Word in Dictionary through Deleting (Medium)](https://leetcode.com/problems/longest-word-in-dictionary-through-deleting/description/)

```
Input:
s = "abpcplea", d = ["ale","apple","monkey","plea"]

Output:
"apple"
```

题目描述：删除 s 中的一些字符，使得它构成字符串列表 d 中的一个字符串，找出能构成的最长字符串。如果有多个相同长度的结果，返回字典序的最小字符串。

```java
public String findLongestWord(String s, List<String> d) {
    String longestWord = "";
    for (String target : d) {
        int l1 = longestWord.length(), l2 = target.length();
        if (l1 > l2 || (l1 == l2 && longestWord.compareTo(target) < 0)) {
            continue;
        }
        if (isValid(s, target)) {
            longestWord = target;
        }
    }
    return longestWord;
}

private boolean isValid(String s, String target) {
    int i = 0, j = 0;
    while (i < s.length() && j < target.length()) {
        if (s.charAt(i) == target.charAt(j)) {
            j++;
        }
        i++;
    }
    return j == target.length();
}
```

```js
function isValid(s, target) {
    var i = 0,
        j = 0;
    while (i < s.length && j < target.length) {
        if (s.charAt(i) === target.charAt(j)) {
            j++;
        } else {
            i++;
        }
    }
    if (j == target.length) {
        return true;
    }
}

function findLongestWord(s, str) {
    var l1 = 0,
        l2 = 0,
        longestWord = '';
    for (var target of str) {
        l1 = longestWord.length;
        l2 = target.length;
        if (l1 > l2 || (l1 == l2 && longestWord !== target)) {
            continue;
        }

        if (isValid(s, target)) {
            longestWord = target;
        }
    }

    return longestWord;
}
```
